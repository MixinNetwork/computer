# Mixin Safe

Mixin Safe is an advanced non-custody solution for securing BTC using the native Bitcoin multisig and timelock script. The 2/3 multisig comprises three keys: the holder, signer, and observer. The BTC locked in the script can only be spent when the holder and signer keys sign a transaction, provided that the timelock of one year is in effect. In the event of key loss by the holder or signer, the observer can act as rescuer after one year.

The signer key, which is MPC generated by Mixin Safe nodes, is controlled in a decentralized manner. Whenever a deposit is made into a safe account, Mixin Safe issues the same amount of safeBTC to the account owner. To make the signer key sign a transaction with the holder, the account owner needs to send safeBTC to the Mixin Safe network and sign the raw transaction with the holder key.


## Prepare Holder Key

Currently, there aren't many Bitcoin wallets that can perform custom script signing, not even the bitcoin-core wallet. It's therefore recommended to use btcd, which can be accessed at https://github.com/btcsuite/btcd.

Using btcd, you can generate a public and private key pair using the following code:

```golang
priv, pub := btcec.PrivKeyFromBytes(seed)
fmt.Printf("public: %x\nprivate: %x\n", pub.SerializeCompressed(), priv.Serialize())

`
public: 039c2f5ebdd4eae6d69e7a98b737beeb78e0a8d42c7b957a0fbe0c41658d16ab40
private: 1b639e995830c253eb38780480440a72919f5448be345a574c545329f2df4d76
`
```

After generating the key pair, you will need to create a random UUID as the session ID. The following UUID will be used as example:

```
2e78d04a-e61a-442d-a014-dec19bd61cfe
```


## Propose Safe Account

All messages to the safe network should be encoded as the following operation struct

```golang
type Operation struct {
	Id     string
	Type   uint8
	Curve  uint8
	Public string
	Extra  []byte
}

func (o *Operation) Encode() []byte {
	pub, err := hex.DecodeString(o.Public)
	if err != nil {
		panic(o.Public)
	}
	enc := common.NewEncoder()
	writeUUID(enc, o.Id)
	writeByte(enc, o.Type)
	writeByte(enc, o.Curve)
	writeBytes(enc, pub)
	writeBytes(enc, o.Extra)
	return enc.Bytes()
}
```

To send the account proposal, with the holder prepared from last step, the operation value should be like

```golang
op := &Operation {
  Id: "2e78d04a-e61a-442d-a014-dec19bd61cfe",
  Type: 110,
  Curve: 1,
  Public: "039c2f5ebdd4eae6d69e7a98b737beeb78e0a8d42c7b957a0fbe0c41658d16ab40",
}
```

All these four fields above are mandatory for all safe network messages, now we need to make the extra.

```golang
threshold := byte(1)
total := byte(1)
owners := []string{"fcb87491-4fa0-4c2f-b387-262b63cbc112"}
extra := []byte{threshold, total}
uid := uuid.FromStringOrNil(owners[0])
op.Extra = append(extra, uid.Bytes()...)
```

So the safe account proposal operation extra is encoded with threshold, owners count, and all owner UUIDs.

Then we can encode the operation and use it as a memo to send the transaction to safe network MTG.

```golang
memo := base64.RawURLEncoding.EncodeToString(op.Encode())
input := mixin.TransferInput{
  AssetID: "c6d0c728-2624-429b-8e0d-d9d19b6592fa",
  Amount:  decimal.NewFromFloat(0.0001),
  TraceID: op.Id,
  Memo:    memo,
}
input.OpponentMultisig.Receivers = []{
  "71b72e67-3636-473a-9ee4-db7ba3094057",
  "148e696f-f1db-4472-a907-ceea50c5cfde",
  "c9a9a719-4679-4057-bcf0-98945ed95a81",
  "b45dcee0-23d7-4ad1-b51e-c681a257c13e",
  "fcb87491-4fa0-4c2f-b387-262b63cbc112",
}
input.OpponentMultisig.Threshold = 4
```


## Approve Safe Account

After the proposal transaction sent to the safe network MTG, you can monitor the Mixin Network transactions to decode your account details, but to make it easy, it's possible to just fetch it from the Safe HTTP API.

```
curl https://safe.mixin.dev/accounts/2e78d04a-e61a-442d-a014-dec19bd61cfe
{"accountant":"bc1qevu9qqpfqp4s9jq3xxulfh08rgyjy8rn76aj7e","address":"bc1qzccxhrlm4p5l5rpgnns58862ckmsat7uxucqjfcfmg7ef6yltf3quhr94a","id":"2e78d04a-e61a-442d-a014-dec19bd61cfe","script":"6352670399f040b2752102b4868f0800a8268ea24e0ba96c61d251ec199275b955cd48fb9af2302ef250f2ad516821039c2f5ebdd4eae6d69e7a98b737beeb78e0a8d42c7b957a0fbe0c41658d16ab402102c4f8174c09969f7e37ae0d2d1cb02d945625595054cf8d6fff05e0d96e9e0bc052ae","status":"proposed"}
```

You should have noticed that the request was made with the same session UUID we prepared at the first step. That address returned is our safe account address to receive BTC, but to start using it, we must approve it with our holder key.


```golang
var buf bytes.Buffer
_ = wire.WriteVarString(&buf, 0, "Bitcoin Signed Message:\n")
_ = wire.WriteVarString(&buf, 0, address)
hash := chainhash.DoubleHashB(buf.Bytes())
b, _ := hex.DecodeString(priv)
private, _ := btcec.PrivKeyFromBytes(b)
sig := ecdsa.Sign(private, hash)
fmt.Println(base64.RawURLEncoding.EncodeToString(sig.Serialize()))

`MEUCIQCY3Gl1uocJR-qa2wVUuvK_gc-pOxzk8Zq_x_Hqv8iJbAIgXPbMuk-GiGsM3MJKmQ3haRzfDEKSBHArkgRF2NtxDOk`
```

With the signature we send the request to safe network to prove that we own the holder key exactly.

```
curl https://safe.mixin.dev/accounts/2e78d04a-e61a-442d-a014-dec19bd61cfe -H 'Content-Type:application/json' \
  -d '{"address":"bc1qzccxhrlm4p5l5rpgnns58862ckmsat7uxucqjfcfmg7ef6yltf3quhr94a","signature":"MEUCIQCY3Gl1uocJR-qa2wVUuvK_gc-pOxzk8Zq_x_Hqv8iJbAIgXPbMuk-GiGsM3MJKmQ3haRzfDEKSBHArkgRF2NtxDOk"}'
{"accountant":"bc1qevu9qqpfqp4s9jq3xxulfh08rgyjy8rn76aj7e","address":"bc1qzccxhrlm4p5l5rpgnns58862ckmsat7uxucqjfcfmg7ef6yltf3quhr94a","id":"2e78d04a-e61a-442d-a014-dec19bd61cfe","script":"6352670399f040b2752102b4868f0800a8268ea24e0ba96c61d251ec199275b955cd48fb9af2302ef250f2ad516821039c2f5ebdd4eae6d69e7a98b737beeb78e0a8d42c7b957a0fbe0c41658d16ab402102c4f8174c09969f7e37ae0d2d1cb02d945625595054cf8d6fff05e0d96e9e0bc052ae","status":"proposed"}
```

Now we can deposit BTC to the address above, and you will receive safeBTC to the owner wallet.


## Propose Safe Transaction

After deposited some BTC to both the safe address and accountant, now we want to send 0.000123BTC to bc1qxzueu7tguufapq8d63ma5fm2al7ck06rrq3fl4.

First we need to generate another random session id

```
84b390fe-0fff-4a13-b8a7-05810421fd62
```

Then with the holder prepared from first step, the operation value should be like

```golang
op := &Operation {
  Id: "84b390fe-0fff-4a13-b8a7-05810421fd62",
  Type: 112,
  Curve: 1,
  Public: "039c2f5ebdd4eae6d69e7a98b737beeb78e0a8d42c7b957a0fbe0c41658d16ab40",
  Extra: []byte("bc1qxzueu7tguufapq8d63ma5fm2al7ck06rrq3fl4"),
}
```

Then we get the safeBTC asset id we received when deposit BTC to the safe address, all safe accounts have different safe assets, the demo safe account has the safeBTC asset id `94c178c5-b36f-36f5-a4fb-411c0966526c`.

```golang
memo := base64.RawURLEncoding.EncodeToString(op.Encode())
input := mixin.TransferInput{
  AssetID: "94c178c5-b36f-36f5-a4fb-411c0966526c",
  Amount:  decimal.NewFromFloat(0.0002),
  TraceID: op.Id,
  Memo:    memo,
}
input.OpponentMultisig.Receivers = []{
  "71b72e67-3636-473a-9ee4-db7ba3094057",
  "148e696f-f1db-4472-a907-ceea50c5cfde",
  "c9a9a719-4679-4057-bcf0-98945ed95a81",
  "b45dcee0-23d7-4ad1-b51e-c681a257c13e",
  "fcb87491-4fa0-4c2f-b387-262b63cbc112",
}
input.OpponentMultisig.Threshold = 4
```

After the transaction sent successfully to the safe network MTG, we can query the safe API to get the proposed raw transaction.

```
curl https://safe.mixin.dev/transactions/84b390fe-0fff-4a13-b8a7-05810421fd62
{"fee":"0.00023352","hash":"82691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb8","id":"84b390fe-0fff-4a13-b8a7-05810421fd62","raw":"002082691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb801690200000006e0524c3468d89925aef3ebc8daaa4fc3cb22af7adf4533039a334c8e905d70bd0000000000ffffffff45bbb1a3e11ca83482839a1706f0c26cd65011eb3a4fdf3ded69750568c960370000000000ffffffffb8109b00829cb9404d5dc98d4207837c0c70d1d5203dfee7dad583d8cd544ca00000000000ffffffff5a51f279fafdbfde21a3dda1b108dbfe0a6260812ed422bc42d1607e17bb88f60000000000ffffffff7deeb70ae55424ab67e995deae04d7f3977fee1282b44da979d34c970617d2470000000000ffffffffe12cf09637cd791d14807c2c06381d4a95076333b422d55705dc39b2a1d962200000000000ffffffff030c3000000000000016001430b99e7968e713d080edd477da276aeffd8b3f432e5f000000000000220020f89b82f647fc65dd812c09094dbdbe54aaa2a587d080554b4285197ccd9d07fe7842000000000000160014842708e00503f4a1a1abf4db201f231de47b9f730000000000c047bf4d6321c7105d6e803fb2bff2aa11abcbd717678e47a59833499277c73e11b3b550dcd91135781352e7c8b3f91494f2d0c063abe9fd1495dbfab79cabf4f3a50d3501d127107ace5eba404327be5d5807d0bfedd877ae5a15dbafa3519b50a60715ac92669d47b26da0aec86f6c68d382864c88e992f2389553b1389d7e5112ee1769414d1e7e6a9c8d50fae6bd7c1f801424c3ae63e03a9ea23841a27296e5ea4c72c163d830b02a6710ffa749e32eeedddfe1825e94585111af6ae233a40000000000005b38"}
```


## Approve Safe Transaction

With the transaction proposed in previous step, we can decode the raw response to get the underline bitcoin raw transaction and signature hashes for the holder key to sign.

```golang
b, _ := hex.DecodeString(raw)
dec := common.NewDecoder(b)
hash, _ := dec.ReadBytes()
rawBytes, _ := dec.ReadBytes()
sigHashes, _ := dec.ReadBytes()
fee, _ := dec.ReadUint64()
```

With the decoded raw bytes, we can parse it to see all its inputs and outputs, and verify it's correct as we proposed. Then we sign all signature hashes with our holder private key.

```golang
script := theSafeAccountScript()
tx, _ := btcutil.NewTxFromBytes(rawBytes)
msgTx := tx.MsgTx()
partials := make(map[int][]byte)
for idx := range msgTx.TxIn {
	pop := vin.PreviousOutPoint
	satoshi := getUTXOValueFromRPC(pop.Hash.String(), pop.Index)
	pof := txscript.NewCannedPrevOutputFetcher(script, satoshi)
	tsh := txscript.NewTxSigHashes(msgTx, pof)
	hash, _ := txscript.CalcWitnessSigHash(script, tsh, txscript.SigHashAll, msgTx, idx, satoshi)
	if bytes.Equal(hash, rtx.SigHashes[idx*32 : idx*32+32]) {
		partials[idx] = ecdsa.Sign(holder, hash).Serialize()
	}
}
pb, _ := json.Marshal(partials)
fmt.Printf("partials: %x\n", pb)

var buf bytes.Buffer
_ = wire.WriteVarString(&buf, 0, "Bitcoin Signed Message:\n")
_ = wire.WriteVarString(&buf, 0, msgTx.TxHash().String())
hash := chainhash.DoubleHashB(buf.Bytes())
sig := ecdsa.Sign(holder, msg).Serialize()
fmt.Printf("signature: %s\n", base64.RawURLEncoding.EncodeToString(sig))
```

After we have the partials available, then we can send them to safe API.

```
curl https://safe.mixin.dev/transactions/84b390fe-0fff-4a13-b8a7-05810421fd62 -H 'Content-Type:application/json' \
  -d '{"action":"approve","raw":"002082691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb801690200000006e0524c3468d89925aef3ebc8daaa4fc3cb22af7adf4533039a334c8e905d70bd0000000000ffffffff45bbb1a3e11ca83482839a1706f0c26cd65011eb3a4fdf3ded69750568c960370000000000ffffffffb8109b00829cb9404d5dc98d4207837c0c70d1d5203dfee7dad583d8cd544ca00000000000ffffffff5a51f279fafdbfde21a3dda1b108dbfe0a6260812ed422bc42d1607e17bb88f60000000000ffffffff7deeb70ae55424ab67e995deae04d7f3977fee1282b44da979d34c970617d2470000000000ffffffffe12cf09637cd791d14807c2c06381d4a95076333b422d55705dc39b2a1d962200000000000ffffffff030c3000000000000016001430b99e7968e713d080edd477da276aeffd8b3f432e5f000000000000220020f89b82f647fc65dd812c09094dbdbe54aaa2a587d080554b4285197ccd9d07fe7842000000000000160014842708e00503f4a1a1abf4db201f231de47b9f730000000000c047bf4d6321c7105d6e803fb2bff2aa11abcbd717678e47a59833499277c73e11b3b550dcd91135781352e7c8b3f91494f2d0c063abe9fd1495dbfab79cabf4f3a50d3501d127107ace5eba404327be5d5807d0bfedd877ae5a15dbafa3519b50a60715ac92669d47b26da0aec86f6c68d382864c88e992f2389553b1389d7e5112ee1769414d1e7e6a9c8d50fae6bd7c1f801424c3ae63e03a9ea23841a27296e5ea4c72c163d830b02a6710ffa749e32eeedddfe1825e94585111af6ae233a40000000000005b38","partials":"7b2230223a224d45514349417659475757446637734d65323364314132382b393344376963592f70556d7565386d543050354253703641694144486e364661556f55797552695779456842624a50634f467261496f455463484d436d384e5345457573673d3d222c2231223a224d45554349514431326f68585a34594b6e5967416a4a4e6d50486d714a664c634b434b37655a617873566e47736434657441496747424c6173397537314948673941584645345436384839346268395a7157416144453873323077457762733d222c2232223a224d45554349514354517a50643445526c687a4b753931326c4b4f713942715a7048566b2b4c776861567679552b4b68574b4149675a48564e3432764c77696e7768706e734e674e4f6f6a54516a32334a4c6631466a306a7a7577346f6744673d222c2233223a224d45554349514361357953445542527357364d4564752b69437a344866516d4f584e5855427a324b413532316f2b4572305149674f7a4974446b6f33704b4f33785467774e6f354678436777434158356a6f4a73355575552f487a684d48773d222c2234223a224d4551434941697241695055663678564f33316a4d30794c30506d426a56624c574e463931574b4b674c706d3151374e416941346a695a3731425442372f43574f554e4a5a7a4438534a643756744a6c6231747759574f4a6c44535730413d3d222c2235223a224d4551434947613532686d45616758654a3373545447353335494743704c4c446970393051684461467636475473702f41694145613568527150353364686a6c514c615972734a31483559306e416d7a633859387661786c2f64504c32773d3d227d","signature":"MEUCIQC3HczYJpEeDJL1b2-qezUJj-B2pHGo8-X3HKn_JO5NxgIgYm_Cxj0BP7FLzOl4hCcUZ5-YxyXOhaDsiYRndvOXUnE"}'
{"fee":"0.00023352","hash":"82691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb8","id":"84b390fe-0fff-4a13-b8a7-05810421fd62","raw":"002082691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb801690200000006e0524c3468d89925aef3ebc8daaa4fc3cb22af7adf4533039a334c8e905d70bd0000000000ffffffff45bbb1a3e11ca83482839a1706f0c26cd65011eb3a4fdf3ded69750568c960370000000000ffffffffb8109b00829cb9404d5dc98d4207837c0c70d1d5203dfee7dad583d8cd544ca00000000000ffffffff5a51f279fafdbfde21a3dda1b108dbfe0a6260812ed422bc42d1607e17bb88f60000000000ffffffff7deeb70ae55424ab67e995deae04d7f3977fee1282b44da979d34c970617d2470000000000ffffffffe12cf09637cd791d14807c2c06381d4a95076333b422d55705dc39b2a1d962200000000000ffffffff030c3000000000000016001430b99e7968e713d080edd477da276aeffd8b3f432e5f000000000000220020f89b82f647fc65dd812c09094dbdbe54aaa2a587d080554b4285197ccd9d07fe7842000000000000160014842708e00503f4a1a1abf4db201f231de47b9f730000000000c047bf4d6321c7105d6e803fb2bff2aa11abcbd717678e47a59833499277c73e11b3b550dcd91135781352e7c8b3f91494f2d0c063abe9fd1495dbfab79cabf4f3a50d3501d127107ace5eba404327be5d5807d0bfedd877ae5a15dbafa3519b50a60715ac92669d47b26da0aec86f6c68d382864c88e992f2389553b1389d7e5112ee1769414d1e7e6a9c8d50fae6bd7c1f801424c3ae63e03a9ea23841a27296e5ea4c72c163d830b02a6710ffa749e32eeedddfe1825e94585111af6ae233a40000000000005b38"}
```

A few minutes later, we should be able to query the transaction on a Bitcoin explorer.

https://blockstream.info/tx/82691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb8?expand
