# Mixin Safe

Mixin Safe uses the native Bitcoin multisig and timelock script as a state-of-the-art solution to secure BTC. The 2/3 multisig is composed of three keys, holder, signer and observer. With a timelock of 1 year, if and only if holder and signer both sign the transaction, the BTC can be spent. In any case of holder or signer key lost, the observer can be the rescuer after 1 year.

Specifically, the signer key is MPC generated by Mixin Safe nodes, so it's decentralized controlled. Whenever a deposit detected to a safe account, Mixin Safe will issue the same amount of safeBTC to the account owner. To make the signer key sign a transaction with the holder, the account owner needs to send safeBTC to the safe network, and sign the raw transaction with the holder key.

## Prepare Holder Key

There is not much Bitcoin wallets can do custom script signing, not even the bitcoin-core wallet. So for now it's recommended to use https://github.com/btcsuite/btcd.

With btcd you can generate a public and private key pair as below:

```golang
priv, pub := btcec.PrivKeyFromBytes(seed)
fmt.Printf("public: %x\nprivate: %x\n", pub.SerializeCompressed(), priv.Serialize())

`
public: 0389476e12011d38e6aacb830146b6c8a9cf7ad78464139eb5ffa0e5376eb34131
private: 96e18d8d7de1859a6520612c6c05ca14391145913caee12d9939cc6422b08af8
`
```

Then generate a random UUID as the session id:

```
167212be-ab75-4202-8e51-74baa7873265
```

## Propose Safe Account

All messages to the safe network should be encoded as the following operation struct

```golang
type Operation struct {
	Id     string
	Type   uint8
	Curve  uint8
	Public string
	Extra  []byte
}

func (o *Operation) Encode() []byte {
	pub, err := hex.DecodeString(o.Public)
	if err != nil {
		panic(o.Public)
	}
	enc := common.NewEncoder()
	writeUUID(enc, o.Id)
	writeByte(enc, o.Type)
	writeByte(enc, o.Curve)
	writeBytes(enc, pub)
	writeBytes(enc, o.Extra)
	return enc.Bytes()
}
```

To send the account proposal, with the holder prepared from last step, the operation value should be like

```golang
op := &Operation {
  Id: "167212be-ab75-4202-8e51-74baa7873265",
  Type: 110,
  Curve: 1,
  Public: "0389476e12011d38e6aacb830146b6c8a9cf7ad78464139eb5ffa0e5376eb34131",
}
```

All these four fields above are mandatory for all safe network messages, now we need to make the extra.

```golang
threshold := byte(1)
total := byte(1)
owners := []string{"fcb87491-4fa0-4c2f-b387-262b63cbc112"}
extra := []byte{threshold, total}
uid := uuid.FromStringOrNil(owners[0])
op.Extra = append(extra, uid.Bytes()...)
```

So the safe account proposal operation extra is encoded with threshold, owners count, and all owner UUIDs.

Then we can encode the operation and use it as a memo to send the transaction to safe network MTG.

```golang
memo := base64.RawURLEncoding.EncodeToString(op.Encode())
input := mixin.TransferInput{
  AssetID: "c6d0c728-2624-429b-8e0d-d9d19b6592fa",
  Amount:  decimal.NewFromFloat(0.0001),
  TraceID: op.Id,
  Memo:    memo,
}
input.OpponentMultisig.Receivers = []{
  "71b72e67-3636-473a-9ee4-db7ba3094057",
  "148e696f-f1db-4472-a907-ceea50c5cfde",
  "c9a9a719-4679-4057-bcf0-98945ed95a81",
  "b45dcee0-23d7-4ad1-b51e-c681a257c13e",
  "fcb87491-4fa0-4c2f-b387-262b63cbc112",
}
input.OpponentMultisig.Threshold = 4
```


## Approve Safe Account

After the proposal transaction sent to the safe network MTG, you can monitor the Mixin Network transactions to decode your account details, but to make it easy, it's possible to just fetch it from the Safe HTTP API.

```
curl https://safe.mixin.dev/accounts/167212be-ab75-4202-8e51-74baa7873265
{"accountant":"bc1qssns3cq9q062rgdt7ndjq8errhj8h8mnyd9494","address":"bc1qlzdc9aj8l3jamqfvpyy5m0d72j429fv86zq92j6zs5vhenvaqllqzdst7c","id":"167212be-ab75-4202-8e51-74baa7873265","status":"proposed"}
```

You should have noticed that the request was made with the same session UUID we prepared at the first step. That address returned is our safe account address to receive BTC, but to start using it, we must approve it with our holder key.


```golang
var buf bytes.Buffer
_ = wire.WriteVarString(&buf, 0, "Bitcoin Signed Message:\n")
_ = wire.WriteVarString(&buf, 0, address)
hash := chainhash.DoubleHashB(buf.Bytes())
b, _ := hex.DecodeString(priv)
private, _ := btcec.PrivKeyFromBytes(b)
sig := ecdsa.Sign(private, hash)
fmt.Println(base64.RawURLEncoding.EncodeToString(sig.Serialize()))

`MEQCIAlx1nCFx64KiKyNX-F1H3yv4B6SpUb0_46JgbC_jD-3AiBJ3OW9LaoMWwYHdF_lVrd7iZJlCYVHXiF40ngUrZYoww`
```

With the signature we send the request to safe network to prove that we own the holder key exactly.

```
curl https://safe.mixin.dev/accounts/167212be-ab75-4202-8e51-74baa7873265 -H 'Content-Type:application/json' \
  -d '{"address":"bc1qlzdc9aj8l3jamqfvpyy5m0d72j429fv86zq92j6zs5vhenvaqllqzdst7c","signature":"MEQCIAlx1nCFx64KiKyNX-F1H3yv4B6SpUb0_46JgbC_jD-3AiBJ3OW9LaoMWwYHdF_lVrd7iZJlCYVHXiF40ngUrZYoww"}'
{"accountant":"bc1qssns3cq9q062rgdt7ndjq8errhj8h8mnyd9494","address":"bc1qlzdc9aj8l3jamqfvpyy5m0d72j429fv86zq92j6zs5vhenvaqllqzdst7c","id":"167212be-ab75-4202-8e51-74baa7873265","status":"proposed"}
```

Now we can deposit BTC to the address above, and you will receive safeBTC to the owner wallet.


## Propose Safe Transaction

After deposited some BTC to both the safe address and accountant, now we want to send 0.000123BTC to bc1qxzueu7tguufapq8d63ma5fm2al7ck06rrq3fl4.

First we need to generate another random session id

```
84b390fe-0fff-4a13-b8a7-05810421fd62
```

Then with the holder prepared from first step, the operation value should be like

```golang
op := &Operation {
  Id: "84b390fe-0fff-4a13-b8a7-05810421fd62",
  Type: 112,
  Curve: 1,
  Public: "0389476e12011d38e6aacb830146b6c8a9cf7ad78464139eb5ffa0e5376eb34131",
  Extra: []byte("bc1qxzueu7tguufapq8d63ma5fm2al7ck06rrq3fl4"),
}
```

Then we get the safeBTC asset id we received when deposit BTC to the safe address, all safe accounts have different safe assets, the demo safe account has the safeBTC asset id `94c178c5-b36f-36f5-a4fb-411c0966526c`.

```golang
memo := base64.RawURLEncoding.EncodeToString(op.Encode())
input := mixin.TransferInput{
  AssetID: "94c178c5-b36f-36f5-a4fb-411c0966526c",
  Amount:  decimal.NewFromFloat(0.0002),
  TraceID: op.Id,
  Memo:    memo,
}
input.OpponentMultisig.Receivers = []{
  "71b72e67-3636-473a-9ee4-db7ba3094057",
  "148e696f-f1db-4472-a907-ceea50c5cfde",
  "c9a9a719-4679-4057-bcf0-98945ed95a81",
  "b45dcee0-23d7-4ad1-b51e-c681a257c13e",
  "fcb87491-4fa0-4c2f-b387-262b63cbc112",
}
input.OpponentMultisig.Threshold = 4
```

After the transaction sent successfully to the safe network MTG, we can query the safe API to get the proposed raw transaction.

```
curl https://safe.mixin.dev/transactions/84b390fe-0fff-4a13-b8a7-05810421fd62
{"fee":"0.00023352","hash":"82691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb8","id":"84b390fe-0fff-4a13-b8a7-05810421fd62","raw":"002082691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb801690200000006e0524c3468d89925aef3ebc8daaa4fc3cb22af7adf4533039a334c8e905d70bd0000000000ffffffff45bbb1a3e11ca83482839a1706f0c26cd65011eb3a4fdf3ded69750568c960370000000000ffffffffb8109b00829cb9404d5dc98d4207837c0c70d1d5203dfee7dad583d8cd544ca00000000000ffffffff5a51f279fafdbfde21a3dda1b108dbfe0a6260812ed422bc42d1607e17bb88f60000000000ffffffff7deeb70ae55424ab67e995deae04d7f3977fee1282b44da979d34c970617d2470000000000ffffffffe12cf09637cd791d14807c2c06381d4a95076333b422d55705dc39b2a1d962200000000000ffffffff030c3000000000000016001430b99e7968e713d080edd477da276aeffd8b3f432e5f000000000000220020f89b82f647fc65dd812c09094dbdbe54aaa2a587d080554b4285197ccd9d07fe7842000000000000160014842708e00503f4a1a1abf4db201f231de47b9f730000000000c047bf4d6321c7105d6e803fb2bff2aa11abcbd717678e47a59833499277c73e11b3b550dcd91135781352e7c8b3f91494f2d0c063abe9fd1495dbfab79cabf4f3a50d3501d127107ace5eba404327be5d5807d0bfedd877ae5a15dbafa3519b50a60715ac92669d47b26da0aec86f6c68d382864c88e992f2389553b1389d7e5112ee1769414d1e7e6a9c8d50fae6bd7c1f801424c3ae63e03a9ea23841a27296e5ea4c72c163d830b02a6710ffa749e32eeedddfe1825e94585111af6ae233a40000000000005b38"}
```


## Approve Safe Transaction

With the transaction proposed in previous step, we can decode the raw response to get the underline bitcoin raw transaction and signature hashes for the holder key to sign.

```golang
b, _ := hex.DecodeString(raw)
dec := common.NewDecoder(b)
hash, _ := dec.ReadBytes()
rawBytes, _ := dec.ReadBytes()
sigHashes, _ := dec.ReadBytes()
fee, _ := dec.ReadUint64()
```

With the decoded raw bytes, we can parse it to see all its inputs and outputs, and verify it's correct as we proposed. Then we sign all signature hashes with our holder private key.

```golang
script := theSafeAccountScript()
tx, _ := btcutil.NewTxFromBytes(rawBytes)
msgTx := tx.MsgTx()
partials := make(map[int][]byte)
for idx := range msgTx.TxIn {
	pop := vin.PreviousOutPoint
	satoshi := getUTXOValueFromRPC(pop.Hash.String(), pop.Index)
	pof := txscript.NewCannedPrevOutputFetcher(script, satoshi)
	tsh := txscript.NewTxSigHashes(msgTx, pof)
	hash, _ := txscript.CalcWitnessSigHash(script, tsh, txscript.SigHashAll, msgTx, idx, satoshi)
	if bytes.Equal(hash, rtx.SigHashes[idx*32 : idx*32+32]) {
		partials[idx] = ecdsa.Sign(holder, hash).Serialize()
	}
}
pb, _ := json.Marshal(partials)
fmt.Printf("partials: %x\n", pb)

var buf bytes.Buffer
_ = wire.WriteVarString(&buf, 0, "Bitcoin Signed Message:\n")
_ = wire.WriteVarString(&buf, 0, msgTx.TxHash().String())
hash := chainhash.DoubleHashB(buf.Bytes())
sig := ecdsa.Sign(holder, msg).Serialize()
fmt.Printf("signature: %s\n", base64.RawURLEncoding.EncodeToString(sig))
```

After we have the partials available, then we can send them to safe API.

```
curl https://safe.mixin.dev/transactions/84b390fe-0fff-4a13-b8a7-05810421fd62 -H 'Content-Type:application/json' \
  -d '{"action":"approve","raw":"002082691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb801690200000006e0524c3468d89925aef3ebc8daaa4fc3cb22af7adf4533039a334c8e905d70bd0000000000ffffffff45bbb1a3e11ca83482839a1706f0c26cd65011eb3a4fdf3ded69750568c960370000000000ffffffffb8109b00829cb9404d5dc98d4207837c0c70d1d5203dfee7dad583d8cd544ca00000000000ffffffff5a51f279fafdbfde21a3dda1b108dbfe0a6260812ed422bc42d1607e17bb88f60000000000ffffffff7deeb70ae55424ab67e995deae04d7f3977fee1282b44da979d34c970617d2470000000000ffffffffe12cf09637cd791d14807c2c06381d4a95076333b422d55705dc39b2a1d962200000000000ffffffff030c3000000000000016001430b99e7968e713d080edd477da276aeffd8b3f432e5f000000000000220020f89b82f647fc65dd812c09094dbdbe54aaa2a587d080554b4285197ccd9d07fe7842000000000000160014842708e00503f4a1a1abf4db201f231de47b9f730000000000c047bf4d6321c7105d6e803fb2bff2aa11abcbd717678e47a59833499277c73e11b3b550dcd91135781352e7c8b3f91494f2d0c063abe9fd1495dbfab79cabf4f3a50d3501d127107ace5eba404327be5d5807d0bfedd877ae5a15dbafa3519b50a60715ac92669d47b26da0aec86f6c68d382864c88e992f2389553b1389d7e5112ee1769414d1e7e6a9c8d50fae6bd7c1f801424c3ae63e03a9ea23841a27296e5ea4c72c163d830b02a6710ffa749e32eeedddfe1825e94585111af6ae233a40000000000005b38","partials":"7b2230223a224d45514349417659475757446637734d65323364314132382b393344376963592f70556d7565386d543050354253703641694144486e364661556f55797552695779456842624a50634f467261496f455463484d436d384e5345457573673d3d222c2231223a224d45554349514431326f68585a34594b6e5967416a4a4e6d50486d714a664c634b434b37655a617873566e47736434657441496747424c6173397537314948673941584645345436384839346268395a7157416144453873323077457762733d222c2232223a224d45554349514354517a50643445526c687a4b753931326c4b4f713942715a7048566b2b4c776861567679552b4b68574b4149675a48564e3432764c77696e7768706e734e674e4f6f6a54516a32334a4c6631466a306a7a7577346f6744673d222c2233223a224d45554349514361357953445542527357364d4564752b69437a344866516d4f584e5855427a324b413532316f2b4572305149674f7a4974446b6f33704b4f33785467774e6f354678436777434158356a6f4a73355575552f487a684d48773d222c2234223a224d4551434941697241695055663678564f33316a4d30794c30506d426a56624c574e463931574b4b674c706d3151374e416941346a695a3731425442372f43574f554e4a5a7a4438534a643756744a6c6231747759574f4a6c44535730413d3d222c2235223a224d4551434947613532686d45616758654a3373545447353335494743704c4c446970393051684461467636475473702f41694145613568527150353364686a6c514c615972734a31483559306e416d7a633859387661786c2f64504c32773d3d227d","signature":"MEUCIQC3HczYJpEeDJL1b2-qezUJj-B2pHGo8-X3HKn_JO5NxgIgYm_Cxj0BP7FLzOl4hCcUZ5-YxyXOhaDsiYRndvOXUnE"}'
{"fee":"0.00023352","hash":"82691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb8","id":"84b390fe-0fff-4a13-b8a7-05810421fd62","raw":"002082691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb801690200000006e0524c3468d89925aef3ebc8daaa4fc3cb22af7adf4533039a334c8e905d70bd0000000000ffffffff45bbb1a3e11ca83482839a1706f0c26cd65011eb3a4fdf3ded69750568c960370000000000ffffffffb8109b00829cb9404d5dc98d4207837c0c70d1d5203dfee7dad583d8cd544ca00000000000ffffffff5a51f279fafdbfde21a3dda1b108dbfe0a6260812ed422bc42d1607e17bb88f60000000000ffffffff7deeb70ae55424ab67e995deae04d7f3977fee1282b44da979d34c970617d2470000000000ffffffffe12cf09637cd791d14807c2c06381d4a95076333b422d55705dc39b2a1d962200000000000ffffffff030c3000000000000016001430b99e7968e713d080edd477da276aeffd8b3f432e5f000000000000220020f89b82f647fc65dd812c09094dbdbe54aaa2a587d080554b4285197ccd9d07fe7842000000000000160014842708e00503f4a1a1abf4db201f231de47b9f730000000000c047bf4d6321c7105d6e803fb2bff2aa11abcbd717678e47a59833499277c73e11b3b550dcd91135781352e7c8b3f91494f2d0c063abe9fd1495dbfab79cabf4f3a50d3501d127107ace5eba404327be5d5807d0bfedd877ae5a15dbafa3519b50a60715ac92669d47b26da0aec86f6c68d382864c88e992f2389553b1389d7e5112ee1769414d1e7e6a9c8d50fae6bd7c1f801424c3ae63e03a9ea23841a27296e5ea4c72c163d830b02a6710ffa749e32eeedddfe1825e94585111af6ae233a40000000000005b38"}
```

A few minutes later, we should be able to query the transaction on a Bitcoin explorer.

https://blockstream.info/tx/82691866344969d5a1e59a2fd3dd8b2b4266594f9801e7232bab9baf059b9eb8?expand
